package org.modelix.parser

import net.akehurst.language.agl.grammar.grammar.asm.ChoiceLongestDefault
import net.akehurst.language.agl.grammar.grammar.asm.ConcatenationDefault
import net.akehurst.language.agl.grammar.grammar.asm.GrammarBuilderDefault
import net.akehurst.language.agl.grammar.grammar.asm.NamespaceDefault
import net.akehurst.language.agl.grammar.grammar.asm.NonTerminalDefault
import net.akehurst.language.agl.grammar.grammar.asm.OptionalItemDefault
import net.akehurst.language.api.grammar.RuleItem
import org.modelix.model.api.ConceptReference
import org.modelix.model.api.IConcept

class GrammarTranslator() {
    private val conceptIds = UniqueIdentifiers<ConceptReference>()
    private val conceptHierarchy = ConceptHierarchy()
    private val gb = GrammarBuilderDefault(NamespaceDefault("org.modelix"), "autoGeneratedFromNotation")
    private val conceptsWithRules = HashSet<IConcept>()

    fun aglGrammar() = gb.grammar

    fun conceptRuleName(concept: IConcept) = conceptIds.get(concept.getReference().upcast()) { concept.getShortName() }
    fun conceptChoiceName(concept: IConcept) = "CHOICE_" + conceptRuleName(concept)

    fun load(grammar: Grammar) {
        gb.skip("WHITESPACE", true).concatenation(gb.terminalPattern("""\s+"""))

        for (rule in grammar.rules) {
            conceptHierarchy.loadConcept(rule.outputConcept)
            conceptsWithRules.add(rule.outputConcept)
            load(rule)
        }

        for (superConcept in conceptHierarchy.loadedConcept) {
            val subConcepts = conceptHierarchy.knownSubconcepts[superConcept] ?: emptySet<IConcept>()
            val alternatives = subConcepts.map { NonTerminalDefault(null, conceptChoiceName(it)) } +
                    listOfNotNull(superConcept.takeIf { conceptsWithRules.contains(it) }).map {
                        NonTerminalDefault(
                            null,
                            conceptRuleName(it)
                        )
                    }
            gb.rule(conceptChoiceName(superConcept)).rule.rhs =
                if (alternatives.size == 1) alternatives.single() else ChoiceLongestDefault(alternatives)
        }
    }

    fun load(rule: ProductionRule) {
        val isLeaf = !rule.rhs.getAllSymbols().filterIsInstance<ChildLinkSymbol>().any()
        val name = conceptRuleName(rule.outputConcept)
        (if (isLeaf) gb.leaf(name) else gb.rule(name)).rule.rhs = translate(rule.rhs)
    }

    fun translate(symbol: ISymbol): RuleItem {
        return when (symbol) {
            is OptionalSymbol -> OptionalItemDefault(translate(symbol.symbol))
            is SymbolList -> ConcatenationDefault(symbol.symbols.map { translate(it) })
            is ConstantSymbol -> gb.terminalLiteral(symbol.constant)
            is PropertySymbol -> gb.terminalPattern(symbol.pattern.pattern)
            is ReferenceLinkSymbol -> gb.terminalPattern("[a-zA-Z_][a-zA-Z_0-9]*") // TODO handle references with non-standard names
            is ChildLinkSymbol -> NonTerminalDefault(null, conceptChoiceName(symbol.link.targetConcept))
        }
    }
}
