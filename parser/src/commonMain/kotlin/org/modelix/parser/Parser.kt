package org.modelix.parser

import net.akehurst.language.agl.grammar.grammar.asm.ChoiceLongestDefault
import net.akehurst.language.agl.grammar.grammar.asm.ConcatenationDefault
import net.akehurst.language.agl.grammar.grammar.asm.GrammarBuilderDefault
import net.akehurst.language.agl.grammar.grammar.asm.NamespaceDefault
import net.akehurst.language.agl.grammar.grammar.asm.NonTerminalDefault
import net.akehurst.language.agl.grammar.grammar.asm.OptionalItemDefault
import net.akehurst.language.agl.processor.Agl
import net.akehurst.language.api.grammar.RuleItem
import net.akehurst.language.api.sppt.SharedPackedParseTree
import net.akehurst.language.api.sppt.SpptDataNode
import net.akehurst.language.api.sppt.SpptDataNodeInfo
import net.akehurst.language.api.sppt.SpptWalker
import org.modelix.model.api.ConceptReference
import org.modelix.model.api.IChildLink
import org.modelix.model.api.IConcept
import org.modelix.model.api.IConceptReference
import org.modelix.model.api.IProperty
import org.modelix.model.api.IReferenceLink

class Parser(grammar: Grammar) {
    private val grammar = GrammarTranslator().also { it.load(grammar) }

    fun parse(text: String, goalConcept: IConcept): ParseTreeNode {
        val config = Agl.configuration(Agl.configurationDefault()) {
            this.defaultGoalRuleName(grammar.conceptChoiceName(goalConcept))
        }
        val processor = Agl.processorFromGrammar(grammar.aglGrammar(), config)
        val result = processor.parse(text)
        val tree = result.sppt ?: throw IllegalArgumentException("Failed to parse $text: " + result.issues)
        val converter = ParseTreeConverter()
        tree.treeData.traverseTreeDepthFirst(converter, skipDataAsTree = false)
        return converter.root!!
    }

}

private class ParseTreeConverter : SpptWalker {
    var root: ConceptParseTreeNode? = null
    val stack = ArrayList<ParseTreeNode>()

    override fun beginTree() {
        stack.clear()
        root = null
    }

    override fun beginBranch(nodeInfo: SpptDataNodeInfo) {
        nodeInfo.node.rule
    }

    override fun beginEmbedded(nodeInfo: SpptDataNodeInfo) {
        TODO("Not yet implemented")
    }

    override fun endBranch(nodeInfo: SpptDataNodeInfo) {
        TODO("Not yet implemented")
    }

    override fun endEmbedded(nodeInfo: SpptDataNodeInfo) {
        TODO("Not yet implemented")
    }

    override fun endTree() {
        TODO("Not yet implemented")
    }

    override fun error(msg: String, path: () -> List<SpptDataNode>) {
        TODO("Not yet implemented")
    }

    override fun leaf(nodeInfo: SpptDataNodeInfo) {
        TODO("Not yet implemented")
    }

    override fun skip(startPosition: Int, nextInputPosition: Int) {
        TODO("Not yet implemented")
    }
}

private class UniqueIdentifiers<E>() {
    private val VALID_IDENTIFIER_PATTERN = Regex("[a-zA-Z_][a-zA-Z0-9_]*")
    private val takenIdentifiers = HashSet<String>()
    private val assignedIdentifiers = HashMap<E, String>()

    fun get(key: E, preferredName: () -> String): String {
        return assignedIdentifiers.getOrPut(key) {
            val prefix = toValidIdentifier(preferredName())
            val candidates = sequenceOf(prefix) + (2..1000).asSequence().map { prefix + "_" + it }
            for (candidate in candidates) {
                if (takenIdentifiers.contains(candidate)) continue
                takenIdentifiers.add(candidate)
                return@getOrPut candidate
            }
            error("No many equal names: $preferredName")
        }
    }

    fun toValidIdentifier(s: String): String {
        if (s.matches(VALID_IDENTIFIER_PATTERN)) return s

        val sb = StringBuilder()
        for (i in s.indices) {
            val c = s[i]
            if (i == 0 && c in '0'..'9') {
                sb.append('_')
            }
            if (c == '_' || c in 'a'..'z' || c in 'A'..'Z' || c in '0'..'9') {
                sb.append(c)
            } else {
                sb.append('_')
            }
        }
        return sb.toString()
    }
}

private class ConceptHierarchy() {
    val knownSubconcepts = HashMap<IConcept, MutableSet<IConcept>>()
    val loadedConcept = HashSet<IConcept>()

    fun loadConcept(subConcept: IConcept) {
        if (loadedConcept.contains(subConcept)) return
        loadedConcept.add(subConcept)
        for (superConcept in subConcept.getDirectSuperConcepts()) {
            knownSubconcepts.getOrPut(superConcept) { HashSet() }.add(subConcept)
            loadConcept(superConcept)
        }
    }
}

private class GrammarTranslator() {
    private val conceptIds = UniqueIdentifiers<ConceptReference>()
    private val conceptHierarchy = ConceptHierarchy()
    private val gb = GrammarBuilderDefault(NamespaceDefault("org.modelix"), "autoGeneratedFromNotation")
    private val conceptsWithRules = HashSet<IConcept>()

    fun aglGrammar() = gb.grammar

    fun conceptRuleName(concept: IConcept) = conceptIds.get(concept.getReference().upcast()) { concept.getShortName() }
    fun conceptChoiceName(concept: IConcept) = "CHOICE_" + conceptRuleName(concept)

    fun load(grammar: Grammar) {
        gb.skip("WHITESPACE", true).concatenation(gb.terminalPattern("""\s+"""))

        for (rule in grammar.rules) {
            conceptHierarchy.loadConcept(rule.outputConcept)
            conceptsWithRules.add(rule.outputConcept)
            load(rule)
        }

        for (superConcept in conceptHierarchy.loadedConcept) {
            val subConcepts = conceptHierarchy.knownSubconcepts[superConcept] ?: emptySet<IConcept>()
            val alternatives = subConcepts.map { NonTerminalDefault(null, conceptChoiceName(it)) } +
                    listOfNotNull(superConcept.takeIf { conceptsWithRules.contains(it) }).map { NonTerminalDefault(null, conceptRuleName(it)) }
            gb.rule(conceptChoiceName(superConcept)).rule.rhs =
                if (alternatives.size == 1) alternatives.single() else ChoiceLongestDefault(alternatives)
        }
    }

    fun load(rule: ProductionRule) {
        val isLeaf = !rule.rhs.getAllSymbols().filterIsInstance<ChildLinkSymbol>().any()
        val name = conceptRuleName(rule.outputConcept)
        (if (isLeaf) gb.leaf(name) else gb.rule(name)).rule.rhs = translate(rule.rhs)
    }

    fun translate(symbol: ISymbol): RuleItem {
        return when (symbol) {
            is OptionalSymbol -> OptionalItemDefault(translate(symbol.symbol))
            is SymbolList -> ConcatenationDefault(symbol.symbols.map { translate(it) })
            is ConstantSymbol -> gb.terminalLiteral(symbol.constant)
            is PropertySymbol -> gb.terminalPattern(symbol.pattern.pattern)
            is ReferenceLinkSymbol -> gb.terminalPattern("[a-zA-Z_][a-zA-Z_0-9]*") // TODO handle references with non-standard names
            is ChildLinkSymbol -> NonTerminalDefault(null, conceptChoiceName(symbol.link.targetConcept))
        }
    }
}

private fun IConceptReference.upcast(): ConceptReference = this as ConceptReference

class Grammar(val rules: List<ProductionRule>)

sealed interface ISymbol {
    fun getAllSymbols(): Sequence<ISymbol> = sequenceOf(this)
}
sealed interface ITerminal : ISymbol
sealed interface INonTerminal : ISymbol

interface IRule {
    fun getOutputConcept(): IConcept
    fun getSymbols(): List<ISymbol>
    fun isLeftAssociative(): Boolean
    /**
     * A higher value means a stronger binding of an operator.
     * Smaller numbers will be closer to the root, bigger number closer to the leafs.
     */
    fun getPriority(): Int
}

enum class Associativity {
    NONE,
    LEFT,
    RIGHT
}

class ProductionRule(
    val outputConcept: IConcept,
    val rhs: ISymbol,
    val associativity: Associativity,
    val priority: Int
)

data class ChildLinkSymbol(val link: IChildLink) : INonTerminal
data class ConstantSymbol(val constant: String) : ITerminal
data class PropertySymbol(val property: IProperty, val pattern: Regex) : ITerminal
data class ReferenceLinkSymbol(val link: IReferenceLink) : ITerminal
data class OptionalSymbol(val symbol: ISymbol) : ISymbol
data class SymbolList(val symbols: List<ISymbol>): ISymbol {
    override fun getAllSymbols(): Sequence<ISymbol> = sequenceOf(this) + symbols.asSequence().flatMap { it.getAllSymbols() }
}

sealed class ParseTreeNode(val children: List<ParseTreeNode>)
open class ConceptParseTreeNode(val concept: IConcept, children: List<ParseTreeNode>) : ParseTreeNode(children)
class ChildParseTreeNode(val link: IChildLink, concept: IConcept, children: List<ParseTreeNode>) : ConceptParseTreeNode(concept, children)
class PropertyParseTreeNode(val property: IProperty, val value: String) : ParseTreeNode(emptyList())
class ReferenceParseTreeNode(val link: IReferenceLink, val targetPresentation: String) : ParseTreeNode(emptyList())
class OptionalParseTreeNode(child: ParseTreeNode) : ParseTreeNode(listOf(child))
class ConstantParseTreeNode(val value: String) : ParseTreeNode(emptyList())
