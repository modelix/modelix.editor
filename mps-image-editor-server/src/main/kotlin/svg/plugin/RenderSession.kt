package svg.plugin

/*Generated by MPS */

import com.intellij.ide.ProhibitAWTEvents
import com.intellij.openapi.actionSystem.ActionPlaces
import com.intellij.openapi.actionSystem.AnActionEvent
import com.intellij.openapi.actionSystem.AnActionResult
import com.intellij.openapi.actionSystem.DataContext
import com.intellij.openapi.actionSystem.ex.ActionManagerEx
import com.intellij.openapi.actionSystem.ex.ActionUtil
import com.intellij.openapi.application.EDT
import com.intellij.openapi.application.TransactionGuard
import com.intellij.openapi.application.TransactionGuardImpl
import com.intellij.openapi.keymap.KeymapManager
import io.ktor.server.websocket.DefaultWebSocketServerSession
import io.ktor.websocket.send
import jetbrains.mps.intentions.IntentionsManager
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations
import jetbrains.mps.nodeEditor.EditorComponent
import jetbrains.mps.nodeEditor.cellMenu.NodeSubstituteChooser
import jetbrains.mps.nodeEditor.cells.APICellAdapter
import jetbrains.mps.openapi.editor.cells.EditorCell
import jetbrains.mps.openapi.editor.cells.SubstituteAction
import jetbrains.mps.openapi.editor.extensions.EditorExtensionUtil
import jetbrains.mps.openapi.editor.selection.Selection
import jetbrains.mps.openapi.editor.update.UpdaterListenerAdapter
import jetbrains.mps.openapi.intentions.IntentionExecutable
import jetbrains.mps.project.Project
import jetbrains.mps.util.Pair
import jetbrains.mps.util.SystemInfo
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.boolean
import kotlinx.serialization.json.contentOrNull
import kotlinx.serialization.json.double
import kotlinx.serialization.json.int
import kotlinx.serialization.json.jsonPrimitive
import org.jetbrains.mps.openapi.model.SNode
import org.modelix.model.api.INodeReference
import org.modelix.model.api.NodeReference
import org.modelix.model.api.resolveIn
import org.modelix.model.area.IArea
import org.modelix.model.mpsadapters.MPSArea
import org.modelix.model.mpsadapters.MPSNode
import org.modelix.model.mpsadapters.tomps.ModelixNodeAsMPSNode
import svg.svg.EditorToImage
import svg.util.AWTExtensions
import java.awt.Component
import java.awt.Point
import java.awt.Window
import java.awt.event.KeyEvent
import java.awt.event.MouseEvent
import java.awt.image.BufferedImage
import java.lang.reflect.InvocationTargetException
import java.util.Locale
import javax.swing.JComponent
import javax.swing.KeyStroke
import kotlin.math.ceil
import kotlin.math.roundToInt

private val LOG = io.github.oshai.kotlinlogging.KotlinLogging.logger { }

class RenderSession @JvmOverloads constructor(
    private val project: Project,
    private val websocketSession: DefaultWebSocketServerSession,
    private val user: String,
    isInspector: Boolean = false,
    val inspectorSession: () -> RenderSession?,
    var rootNode: SNode? = null,
) {
    private val MOUSE_EVENT_TYPE: Map<String, Int> = mapOf(
        "mousemove" to MouseEvent.MOUSE_MOVED,
        "mouseenter" to MouseEvent.MOUSE_ENTERED,
        "mouseleave" to MouseEvent.MOUSE_EXITED
    )

    private var serverEditorComponent: ServerEditorComponent? = null
    private var editorId: String? = null

    private var changeDetectionTimer: Job? = null
    private var deltaUpdateCount = 0
    private var imageChangeDetector: EditorChangeDetector? = null
    private var changeDetectionInterval = 1
    private var lastImageTime: Long = 0

    private var lastSelectedIndex = -1
    private var lastIntentions: List<Pair<IntentionExecutable, SNode>>? = null

    var isInspector: Boolean = false

    private var remoteMouseCursor: RemoteMouseCursor? = null

    init {
        this.isInspector = isInspector
        init(project)
    }

    protected fun init(project: Project?) {
        imageChangeDetector = object : EditorChangeDetector(websocketSession) {
            override val editorComponent: EditorComponent
                get() = this@RenderSession.editorComponent

            override suspend fun handleFullChange(newImage: BufferedImage?) {
                changeDetectionInterval = 1
                if (!websocketSession.isActive) {
                    return
                }
                sendFullImage(newImage)
            }

            override suspend fun handlePartialChange(newImage: BufferedImage, offsetX: Int, offsetY: Int) {
                changeDetectionInterval = 1
                if (!websocketSession.isActive) {
                    return
                }
                if (deltaUpdateCount < 20) {
                    sendPartialImage(newImage, offsetX, offsetY)
                } else {
                    sendFullImage(lastImage)
                }
            }
        }

        changeDetectionTimer = websocketSession.launch {
            var counter = 1
            while (isActive) {
                if (counter >= changeDetectionInterval) {
                    counter = 1
                    if (changeDetectionInterval < 500) {
                        changeDetectionInterval = Math.round(ceil(1.5 * changeDetectionInterval)).toInt()
                    }
                    if (isActive) {
                        imageChangeDetector!!.scheduleUpdate()
                    }
                } else {
                    counter++
                }

                if (deltaUpdateCount != 0 && System.currentTimeMillis() - lastImageTime > 3000) {
                    sendFullImage(imageChangeDetector!!.lastImage)
                }
                delay(10)
            }
        }
    }

    suspend fun processCCMenu() {
        if (serverEditorComponent == null) {
            return
        }
        val chooser: NodeSubstituteChooser = serverEditorComponent!!.nodeSubstituteChooser
        val chooserIsVisible: Boolean = chooser.isVisible
        val selectedIndex = if (chooserIsVisible) {
            (
                ReflectionUtil.callMethod(
                    NodeSubstituteChooser::class.java,
                    chooser,
                    "getSelectionIndex",
                    arrayOf<Class<*>?>(),
                    arrayOf<Any?>()
                ) as Int
                )
        } else {
            -1
        }

        if (selectedIndex == lastSelectedIndex) return
        val message = mutableMapOf<String, JsonElement>()
        if (selectedIndex != -1) {
            project.repository.modelAccess.runReadAction {
                message["type"] = JsonPrimitive("ccmenu")
                val contextCell = ReflectionUtil.readField(
                    NodeSubstituteChooser::class.java,
                    chooser,
                    "myContextCell"
                ) as EditorCell
                message["x"] = JsonPrimitive(contextCell.x + contextCell.leftInset)
                message["y"] = JsonPrimitive(contextCell.y + contextCell.height)
                message["selectionIndex"] = JsonPrimitive(
                    ReflectionUtil.callMethod(
                        NodeSubstituteChooser::class.java,
                        chooser,
                        "getSelectionIndex",
                        arrayOf<Class<*>?>(),
                        arrayOf<Any?>()
                    ) as Int
                )
                val pattern: String = chooser.patternEditor.pattern
                message["pattern"] = JsonPrimitive(pattern)
                if (lastSelectedIndex == -1) {
                    val actions: List<SubstituteAction> = ReflectionUtil.callMethod(
                        NodeSubstituteChooser::class.java,
                        chooser,
                        "getSubstituteActions",
                        arrayOf<Class<*>?>(),
                        arrayOf<Any?>()
                    ) as List<SubstituteAction>
                    message["actions"] = JsonArray(
                        actions.map {
                            JsonObject(
                                mapOf(
                                    "pattern" to JsonPrimitive(it.getMatchingText(pattern)),
                                    "description" to JsonPrimitive(it.getDescriptionText(pattern))
                                )
                            )
                        }
                    )
                }
            }
        } else {
            message["type"] = JsonPrimitive("ccmenu.hide")
        }
        lastSelectedIndex = selectedIndex

        sendMessage(message)
    }

    suspend fun sendMessage(message: MutableMap<String, JsonElement>) {
        message["inspector"] = JsonPrimitive(this.isInspector)
        websocketSession.send(JsonObject(message).toString())
    }

    protected val editorComponent: ServerEditorComponent
        get() {
            if (serverEditorComponent == null) {
                val repo = project.repository

                repo.modelAccess.runReadAction {
                    serverEditorComponent = if (this@RenderSession.isInspector) {
                        ServerInspectorEditorComponent(rootNode, project)
                    } else {
                        ServerEditorComponent(rootNode, project)
                    }
                    remoteMouseCursor = RemoteMouseCursor(serverEditorComponent!!.externalComponent)

                    EditorExtensionUtil.extendUsingProject(serverEditorComponent!!, project)
                    serverEditorComponent!!.selectionManager.addSelectionListener { p0, oldSelection, newSelection ->
                        imageChangeDetector!!.scheduleUpdate()
                        inspect(newSelection)
                    }
                    serverEditorComponent!!.updater.addListener(object : UpdaterListenerAdapter() {
                        override fun editorUpdated(p0: jetbrains.mps.openapi.editor.EditorComponent) {
                            imageChangeDetector!!.scheduleUpdate()
                        }
                    })
                }
            }

            return serverEditorComponent!!
        }

    suspend fun sendFullImage(img: BufferedImage?) {
        if (!(websocketSession.isActive)) {
            return
        }
        val png: String = EditorToImage.toPngBase64(img)
        val message = mutableMapOf<String, JsonElement>()
        message["type"] = JsonPrimitive("image.full")
        val data = JsonObject(mapOf("rawData" to JsonPrimitive(png)))
        message["data"] = data
        sendMessage(message)
        deltaUpdateCount = 0
        lastImageTime = System.currentTimeMillis()
    }

    suspend fun sendPartialImage(img: BufferedImage, offsetX: Int, offsetY: Int) {
        val png: String = EditorToImage.toPngBase64(img)
        val message = mutableMapOf<String, JsonElement>()
        message["type"] = JsonPrimitive("image.fragment")
        val data = mutableMapOf<String, JsonElement>()
        data["x"] = JsonPrimitive(offsetX)
        data["y"] = JsonPrimitive(offsetY)
        data["width"] = JsonPrimitive(img.width)
        data["height"] = JsonPrimitive(img.height)
        data["rawData"] = JsonPrimitive(png)
        message["data"] = JsonObject(data)
        sendMessage(message)
        deltaUpdateCount++
        lastImageTime = System.currentTimeMillis()
    }

    suspend fun dispose() {
        if (changeDetectionTimer != null) {
            changeDetectionTimer!!.cancel("disposed")
        }
        if (this.serverEditorComponent != null) {
            withContext(Dispatchers.EDT) { serverEditorComponent!!.dispose() }
        }
    }

    fun onOpen() {
        imageChangeDetector!!.scheduleUpdate()
    }

    fun onClose(code: Int, reason: String?) {
    }

    suspend fun processMessage(message: JsonObject) {
        val data = message["data"] as JsonObject?
        var type = message.optString("type")
        if (type != null) {
            type = type.lowercase(Locale.getDefault())
        }
        val key = data?.optString("key")
        val keyChar = (if (key != null && key.length == 1) key[0] else '\u0000')
        if (type == "click") {
            // The first thing we do is simulating the click to update the selection in the editor.
            withContext(Dispatchers.EDT) {
                remoteMouseCursor!!.mouseClicked(
                    Point(
                        data!!.getInt("x"),
                        data.getInt("y")
                    ),
                    0
                )
            }

            /*
                For following references MPS uses MPSEditorOpener that searches for an open
                tab for the target root node and creates one if it can't find any.
                This seems not to work with ServerEditorComponents so we have to implement
                our own logic for following references.
             */
            if (data?.optBoolean("ctrl") == true || data?.optBoolean("meta") == true) {
                val cell = editorComponent.selectedCell
                if (cell != null && cell.isReferenceCell) {
                    project.repository.modelAccess.runReadAction {
                        val node = APICellAdapter.getSNodeWRTReference(cell)
                        if (node != null) {
                            openNode(node)
                        }
                    }
                }
            }
        } else if (MOUSE_EVENT_TYPE.containsKey(type)) {
            val x = data?.getInt("x")
            val y = data?.getInt("y")
            val modifier =
                (if ((data?.optBoolean("ctrl") == true || data?.optBoolean("meta") == true)) ctrlDownModifier() else 0)
            val mouseEventType: Int = MOUSE_EVENT_TYPE[type]!!
            when (mouseEventType) {
                MouseEvent.MOUSE_MOVED -> withContext(Dispatchers.EDT) {
                    remoteMouseCursor!!.mouseMoved(Point(x!!, y!!), modifier)
                }
                MouseEvent.MOUSE_EXITED -> withContext(Dispatchers.EDT) { remoteMouseCursor!!.mouseExited() }
            }
        } else if (type == "keypress") {
            simulateKeypress(data.getInt("keyCode"), keyChar)
        } else if (type == "keydown") {
            var modifier = 0
            if (data?.optBoolean("ctrl") == true || data?.optBoolean("meta") == true) {
                modifier = modifier or ctrlDownModifier()
            }
            if (data?.optBoolean("alt") == true) {
                modifier = modifier or KeyEvent.ALT_DOWN_MASK
            }
            if (data?.optBoolean("shift") == true) {
                modifier = modifier or KeyEvent.SHIFT_DOWN_MASK
            }
            simulateKeyDown(data.getInt("keyCode"), keyChar, modifier)
        } else if (type == "keyup") {
            simulateKeyUp(data.getInt("keyCode"), keyChar)
        } else if (type == "viewrange") {
            imageChangeDetector!!.setVisibleYRange(message.getInt("top"), message.getInt("bottom"))
            imageChangeDetector!!.scheduleUpdate()
        } else if (type == "rootnode") {
            websocketSession.launch(Dispatchers.EDT) {
                val area: IArea = MPSArea(project.repository)
                val nodeRefString = message.optString("nodeRef")
                if (nodeRefString != null) {
                    area.executeRead {
                        val nodeRef: INodeReference = NodeReference(nodeRefString)
                        val node: SNode = (nodeRef.resolveIn(area)!! as MPSNode).node
                        rootNode = node
                        updateEditorId()
                        this@RenderSession.editorComponent.editNode(node)
                    }
                }
                imageChangeDetector!!.scheduleUpdate()
            }
        } else if (type == "intentions.execute") {
            val index = message.getInt("index")
            val expectedText = message.getString("text")
            if (lastIntentions != null) {
                val intention: Pair<IntentionExecutable, SNode> = lastIntentions!![index]
                withContext(Dispatchers.EDT) {
                    project.repository.modelAccess.executeCommand {
                        val actualText: String =
                            intention.o1.getDescription(intention.o2, editorComponent.editorContext)
                        if (actualText == expectedText) {
                            intention.o1.execute(intention.o2, editorComponent.editorContext)
                        } else {
                            LOG.error("Intention $index is '$actualText' but '$expectedText' was expected")
                        }
                    }
                }
            }
        }

        imageChangeDetector!!.scheduleUpdate()
    }

    private fun updateEditorId() {
        editorId = if (rootNode == null) {
            null
        } else {
            (if (isInspector) "inspector" else "main") + ":rootNode:" + ModelixNodeAsMPSNode.toModelixNode(
                rootNode!!
            ).reference.serialize()
        }
    }

    /**
     * In MacOs Ctrl+click opens the context menu. The behavior we want is the same as in windows Ctrl+click so we need META_DOWN.
     *
     * @return META_DOWN_MASK for macOS, CTRL_DOWN_MASK otherwise
     */
    private fun ctrlDownModifier(): Int {
        return (if (SystemInfo.isMac) KeyEvent.META_DOWN_MASK else KeyEvent.CTRL_DOWN_MASK)
    }

    /**
     * If the given node is in the current editor we select it otherwise we open a new tab.
     *
     * For checking if a node is in the current editor we check if it is a descendent of the root node.
     *
     * Because in Modelix any node can be the root of the editor, we use the node from the editor root cell
     * as root instead of node.containingRoot.
     */
    private fun openNode(node: SNode) {
        val root = editorComponent.rootCell.sNode
        if (SNodeOperations.getNodeAncestors(node, null, false).contains(root)) {
            editorComponent.selectNode(node)
        } else {
            val obj = mutableMapOf<String, JsonElement>()
            obj["type"] = JsonPrimitive("opentab")
            obj["url"] = JsonPrimitive("nodeAsHtml?nodeRef=" + ModelixNodeAsMPSNode.toModelixNode(SNodeOperations.getContainingRoot(node)).reference.serialize())
            websocketSession.launch {
                sendMessage(obj)
            }
        }
    }

    val visibleComponent: JComponent
        get() = editorComponent.externalComponent

    @Throws(InvocationTargetException::class, InterruptedException::class)
    suspend fun simulateKeypress(keyCode: Int, key: Char) {
        withContext<Unit>(Dispatchers.EDT) {
            focusOwner.dispatchEvent(
                KeyEvent(
                    focusOwner,
                    KeyEvent.KEY_TYPED,
                    System.currentTimeMillis(),
                    0,
                    KeyEvent.VK_UNDEFINED,
                    key
                )
            )
        }
    }

    val focusOwner: Component
        get() {
            val editorComponent = editorComponent
            val window: Window = AWTExtensions.getWindow(editorComponent)
            var focusOwner = window.mostRecentFocusOwner
            for (popup in AWTExtensions.getVisibleOwnedWindows(window)) {
                var popupFocusOwner: Component? = popup.mostRecentFocusOwner
                if (popupFocusOwner == null) {
                    popupFocusOwner = popup
                }
                if (popupFocusOwner != null) {
                    focusOwner = popupFocusOwner
                }
            }
            if (focusOwner == null) {
                focusOwner = editorComponent
            }
            return focusOwner
        }

    suspend fun simulateKeyDown(keyCode: Int, key: Char, modifiers: Int) {
        LOG.debug { "down: $keyCode" }
        withContext(Dispatchers.EDT) {
            val focusOwner: Component = this@RenderSession.focusOwner
            val keyEvent = KeyEvent(
                focusOwner,
                KeyEvent.KEY_PRESSED,
                System.currentTimeMillis(),
                modifiers,
                keyCode,
                KeyEvent.CHAR_UNDEFINED
            )

            if (focusOwner !== this@RenderSession.editorComponent || focusOwner === this@RenderSession.editorComponent) {
                focusOwner.dispatchEvent(keyEvent)
                if (keyEvent.isConsumed) {
                    return@withContext
                }
            }

            val dataContext: DataContext = this@RenderSession.editorComponent.dataContext

            if (!(keyEvent.isConsumed)) {
                if (modifiers == KeyEvent.ALT_DOWN_MASK && keyCode == KeyEvent.VK_ENTER) {
                    val message = mutableMapOf<String, JsonElement>()
                    project.repository.modelAccess.runReadAction {
                        message["type"] = JsonPrimitive("intentions")
                        val contextCell: EditorCell = this@RenderSession.editorComponent.selectedCell!!
                        message["x"] = JsonPrimitive(contextCell.x + contextCell.leftInset)
                        message["y"] = JsonPrimitive(contextCell.y + contextCell.height)

                        val query: IntentionsManager.QueryDescriptor = IntentionsManager.QueryDescriptor()
                        query.setEnabledOnly(true)

                        val intentions: Iterable<Pair<IntentionExecutable, SNode>> =
                            IntentionsManager.getInstance().getAvailableIntentions(
                                query,
                                this@RenderSession.editorComponent.selectedNode,
                                this@RenderSession.editorComponent.editorContext
                            )
                        lastIntentions = intentions.toList()
                        message["intentions"] = JsonArray(
                            intentions.map {
                                JsonObject(
                                    mapOf(
                                        "text" to JsonPrimitive(
                                            it.o1.getDescription(
                                                it.o2,
                                                this@RenderSession.editorComponent.editorContext
                                            )
                                        )
                                    )
                                )
                            }
                        )
                    }
                    websocketSession.launch {
                        sendMessage(message)
                    }

                    keyEvent.consume()
                }
            }

            if (!(keyEvent.isConsumed)) {
                // TODO find component local keystroke (see IdeKeyEventDispatcher)
                val keymap = KeymapManager.getInstance().activeKeymap
                val actionIds: Array<String> =
                    keymap.getActionIds(KeyStroke.getKeyStroke(keyCode, modifiers, false))
                if (actionIds.isNotEmpty()) {
                    val actionManager: ActionManagerEx = ActionManagerEx.getInstanceEx()
                    for (actionId in actionIds) {
                        val action = actionManager.getAction(actionId) ?: continue
                        val actionEvent =
                            AnActionEvent.createFromAnAction(action, keyEvent, ActionPlaces.MAIN_MENU, dataContext)
                        ProhibitAWTEvents.start("update").use { token ->
                            (TransactionGuard.getInstance() as TransactionGuardImpl).performUserActivity {
                                @Suppress("removal")
                                ActionUtil.performDumbAwareUpdate(
                                    action,
                                    actionEvent,
                                    true
                                )
                            }
                        }
                        if (!(actionEvent.presentation.isEnabled)) {
                            LOG.debug { "not applicable: $actionId" }
                            continue
                        }

                        actionManager.fireBeforeActionPerformed(action, actionEvent)
                        (TransactionGuard.getInstance() as TransactionGuardImpl).performUserActivity {
//                                AuthorOverride.AUTHOR.runWith(
//                                    user,
//                                    Runnable { action.actionPerformed(actionEvent) })
                            action.actionPerformed(actionEvent)
                        }
                        actionManager.fireAfterActionPerformed(action, actionEvent, AnActionResult.PERFORMED)
                        keyEvent.consume()
                        LOG.debug { "processed by " + actionEvent.presentation.text }
                        break
                    }
                }
            }

//            if (!(keyEvent.isConsumed)) {
//                this@RenderSession.editorComponent.processKeyPressed(keyEvent)
//                if (keyEvent.isConsumed) {
//                    LOG.debug { "processed by editor" }
//                }
//            }
//            if (!(keyEvent.isConsumed) && keyCode != '\u0000'.code) {
//                LOG.debug { "unprocessed keydown: $keyCode" }
//                try {
//                    simulateKeypress(keyCode, key)
//                } catch (ex: Exception) {
//                    throw RuntimeException(ex)
//                }
//            }

            imageChangeDetector!!.scheduleUpdate()
        }
    }

    suspend fun simulateKeyUp(keyCode: Int, key: Char) {
        withContext(Dispatchers.EDT) {
            val focusOwner1: Component = focusOwner
            val keyEvent = KeyEvent(
                focusOwner1,
                KeyEvent.KEY_RELEASED,
                System.currentTimeMillis(),
                0,
                keyCode,
                KeyEvent.CHAR_UNDEFINED
            )
            focusOwner1.dispatchEvent(keyEvent)
            if (!(keyEvent.isConsumed)) {
                LOG.debug { "unprocessed keyup: $keyCode" }
            }
        }
    }

    private fun inspect(newSelection: Selection) {
        if (this.isInspector) {
            return
        }
        val inspectorSession = this.inspectorSession() ?: return
        val node = newSelection.selectedNodes[0]
        if (node != null && inspectorSession.editorComponent.editedNode !== node) {
            inspectorSession.rootNode = node
            inspectorSession.editorComponent.editNode(node)
            inspectorSession.imageChangeDetector!!.scheduleUpdate()
            inspectorSession.updateEditorId()
        }
    }
}

fun JsonObject.optBoolean(name: String): Boolean? = get(name)?.jsonPrimitive?.boolean
fun JsonObject?.getInt(name: String): Int {
    val primitive = this!![name]!!.jsonPrimitive
    return try {
        primitive.int
    } catch (ex: NumberFormatException) {
        primitive.double.roundToInt()
    }
}

fun JsonObject?.getString(name: String): String = this!![name]!!.jsonPrimitive.content
fun JsonObject?.optString(name: String): String? = this?.get(name)?.jsonPrimitive?.contentOrNull
